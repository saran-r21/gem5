diff -ruN gem5_clean/src/mem/cache/replacement_policies/ReplacementPolicies.py gem5/src/mem/cache/replacement_policies/ReplacementPolicies.py
--- gem5_clean/src/mem/cache/replacement_policies/ReplacementPolicies.py	2021-03-24 21:04:51.000000000 +0000
+++ gem5/src/mem/cache/replacement_policies/ReplacementPolicies.py	2023-11-07 02:34:56.242517557 +0000
@@ -44,6 +44,12 @@
     cxx_class = 'ReplacementPolicy::SecondChance'
     cxx_header = "mem/cache/replacement_policies/second_chance_rp.hh"
 
+class LRUIPVRP(BaseReplacementPolicy):
+    type = 'LRUIPVRP'
+    cxx_class = 'ReplacementPolicy::LRUIPVRP'
+    cxx_header = "mem/cache/replacement_policies/lru_ipv.hh"
+    numWays = Param.Int(Parent.assoc, "Set associativity")
+
 class LFURP(BaseReplacementPolicy):
     type = 'LFURP'
     cxx_class = 'ReplacementPolicy::LFU'
diff -ruN gem5_clean/src/mem/cache/replacement_policies/SConscript gem5/src/mem/cache/replacement_policies/SConscript
--- gem5_clean/src/mem/cache/replacement_policies/SConscript	2021-03-24 21:04:51.000000000 +0000
+++ gem5/src/mem/cache/replacement_policies/SConscript	2023-11-07 06:22:49.947301287 +0000
@@ -40,3 +40,4 @@
 Source('second_chance_rp.cc')
 Source('tree_plru_rp.cc')
 Source('weighted_lru_rp.cc')
+Source('lru_ipv.cc')
diff -ruN gem5_clean/src/mem/cache/replacement_policies/lru_ipv.cc gem5/src/mem/cache/replacement_policies/lru_ipv.cc
--- gem5_clean/src/mem/cache/replacement_policies/lru_ipv.cc	1970-01-01 00:00:00.000000000 +0000
+++ gem5/src/mem/cache/replacement_policies/lru_ipv.cc	2023-11-15 22:55:19.864157808 +0000
@@ -0,0 +1,143 @@
+/**
+ * Copyright (c) 2018-2020 Inria
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "mem/cache/replacement_policies/lru_ipv.hh"
+
+#include <cassert>
+#include <memory>
+
+#include "params/LRUIPVRP.hh"
+#include "sim/core.hh"
+
+namespace ReplacementPolicy {
+
+// Constructor for the LRUIPVRP class
+LRUIPVRP::LRUIPVRP(const Params &p)
+  : Base(p), k(0), vectInstance(nullptr), numWays(p.numWays)
+{
+}
+
+// Constructor for the LRUReplData class
+LRUIPVRP::LRUReplData::LRUReplData(int index, std::shared_ptr<LRUIPVvector> Vector)
+  : index(index), Vector(Vector)
+{
+}
+
+// Implementation of the invalidate method
+void LRUIPVRP::invalidate(const std::shared_ptr<ReplacementData>& replacement_data) const
+{
+    // No action needed for invalidation in this policy
+    return;
+}
+
+// Implementation of the touch method
+void LRUIPVRP::touch(const std::shared_ptr<ReplacementData>& replacement_data) const
+{
+    // Cast replacement_data to LRUReplData
+    std::shared_ptr<LRUReplData> Data = std::static_pointer_cast<LRUReplData>(replacement_data);
+    // Get the vector from replacement_data
+    LRUIPVvector* vect = Data->Vector.get();
+
+    // Get the values for updating the vector
+    int New = InsertionVector[Data->index];
+    int Old = vect->at(Data->index);
+    int IPV_Index = 0;
+
+    // Update the vector based on the touch operation
+    while (IPV_Index < vect->size()) {
+        if ((vect->at(IPV_Index) >= New) && (vect->at(IPV_Index) < Old)) {
+            vect->at(IPV_Index) = vect->at(IPV_Index) + 1;
+        }
+        IPV_Index++;
+    }
+    vect->at(Data->index) = New;
+}
+
+// Implementation of the reset method
+void LRUIPVRP::reset(const std::shared_ptr<ReplacementData>& replacement_data) const
+{
+    // Cast replacement_data to LRUReplData
+    std::shared_ptr<LRUReplData> Data = std::static_pointer_cast<LRUReplData>(replacement_data);
+    // Get the vector from replacement_data
+    LRUIPVvector* vect = Data->Vector.get();
+
+    int IPV_Index = 0;
+
+    // Reset the vector when a new entry is inserted
+    while (IPV_Index < vect->size()) {
+        if ((vect->at(IPV_Index) >= InsertionVector[numWays]) && (vect->at(IPV_Index) < numWays)) {
+            vect->at(IPV_Index) = vect->at(IPV_Index) + 1;
+        }
+        IPV_Index++;
+    }
+
+    vect->at(Data->index) = InsertionVector[numWays];
+}
+
+// Implementation of the getVictim method
+ReplaceableEntry* LRUIPVRP::getVictim(const ReplacementCandidates& candidates) const
+{
+    // Ensure that there is at least one candidate
+    assert(candidates.size() > 0);
+    // Cast replacement_data of the first candidate to LRUReplData
+    std::shared_ptr<LRUReplData> Data = std::static_pointer_cast<LRUReplData>(candidates[0]->replacementData);
+    // Get the vector from replacement_data
+    LRUIPVvector* vect = Data->Vector.get();
+    int IPV_Index = 0;
+    int Maximum = 0;
+    int Insert = 0;
+
+    // Find the entry with the maximum value in the vector
+    while (IPV_Index < vect->size()) {
+        if (Maximum < vect->at(IPV_Index)) {
+            Maximum = vect->at(IPV_Index);
+            Insert = IPV_Index;
+        }
+        IPV_Index = IPV_Index + 1;
+    }
+
+    // Return the candidate with the maximum value in its replacement data
+    return candidates[Insert];
+}
+
+// Implementation of the instantiateEntry method
+std::shared_ptr<ReplacementData> LRUIPVRP::instantiateEntry()
+{
+    // Check if a new vector instance needs to be created
+    if (k % numWays == 0) {
+        vectInstance = new LRUIPVvector(numWays, numWays);
+    }
+
+    // Create a new LRUReplData instance and update the counter
+    LRUReplData* Data = new LRUReplData(k % numWays, std::shared_ptr<LRUIPVvector>(vectInstance));
+    k++;
+    return std::shared_ptr<ReplacementData>(Data);
+}
+
+} // namespace ReplacementPolicy
+
diff -ruN gem5_clean/src/mem/cache/replacement_policies/lru_ipv.hh gem5/src/mem/cache/replacement_policies/lru_ipv.hh
--- gem5_clean/src/mem/cache/replacement_policies/lru_ipv.hh	1970-01-01 00:00:00.000000000 +0000
+++ gem5/src/mem/cache/replacement_policies/lru_ipv.hh	2023-11-15 22:55:00.546149827 +0000
@@ -0,0 +1,78 @@
+#ifndef __MEM_CACHE_REPLACEMENT_POLICIES_LRU_IPV_HH__
+#define __MEM_CACHE_REPLACEMENT_POLICIES_LRU_IPV_HH__
+
+#include "mem/cache/replacement_policies/base.hh"
+
+// Forward declaration for LRUIPVRPParams
+struct LRUIPVRPParams;
+namespace ReplacementPolicy {
+
+// Class declaration for LRUIPVRP, inheriting from Base class
+class LRUIPVRP : public Base {
+  protected:
+    const int numWays;           // Number of cache ways
+    int k;                        // Counter for instantiation
+    typedef std::vector<int> LRUIPVvector;  // Type definition for vector
+    LRUIPVvector *vectInstance;    // Instance of the vector
+
+    // Struct for replacement data, inheriting from ReplacementData
+    struct LRUReplData : ReplacementData {
+        Tick lastTouchTick;         // Timestamp of the last touch
+        mutable int index;          // Mutable index for replacement
+        std::shared_ptr<LRUIPVvector> Vector;  // Shared pointer to the vector
+        LRUReplData(int assoc, std::shared_ptr<LRUIPVvector> Vector);
+    };
+
+    // Initialization of the InsertionVector with predefined values
+    const std::vector<int> InsertionVector{0, 0, 1, 0, 2, 0, 1, 2, 1, 0, 6, 1, 0, 0, 1, 11, 12};
+
+  public:
+    // Type definition for LRUIPVRPParams
+    typedef LRUIPVRPParams Params;
+    LRUIPVRP(const Params &p);  // Constructor for LRUIPVRP
+    ~LRUIPVRP() {}              // Destructor
+
+    /**
+     * Invalidate replacement data to set it as the next probable victim.
+     * Sets its last touch tick as the starting tick.
+     *
+     * @param replacement_data Replacement data to be invalidated.
+     */
+    void invalidate(const std::shared_ptr<ReplacementData>& replacement_data) const override;
+
+    /**
+     * Touch an entry to update its replacement data.
+     * Sets its last touch tick as the current tick.
+     *
+     * @param replacement_data Replacement data to be touched.
+     */
+    void touch(const std::shared_ptr<ReplacementData>& replacement_data) const override;
+
+    /**
+     * Reset replacement data. Used when an entry is inserted.
+     * Sets its last touch tick as the current tick.
+     *
+     * @param replacement_data Replacement data to be reset.
+     */
+    void reset(const std::shared_ptr<ReplacementData>& replacement_data) const override;
+
+    /**
+     * Find replacement victim using LRU timestamps.
+     *
+     * @param candidates Replacement candidates, selected by indexing policy.
+     * @return Replacement entry to be replaced.
+     */
+    ReplaceableEntry* getVictim(const ReplacementCandidates& candidates) const override;
+
+    /**
+     * Instantiate a replacement data entry.
+     *
+     * @return A shared pointer to the new replacement data.
+     */
+    std::shared_ptr<ReplacementData> instantiateEntry() override;
+};
+
+}  // namespace ReplacementPolicy
+
+#endif // __MEM_CACHE_REPLACEMENT_POLICIES_LRU_IPV_HH__
+
